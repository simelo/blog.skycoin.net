+++
title = "Obelisk 합의 알고리즘 개발 동기"
tags = [
    "Obelisk",
    "Consensus",
    "Skywire",
]
date = "2017-10-26"
categories = [
    "Statement",
]
bounty = 20
+++

*이것은 2014 년 6월 19일 비트코인토크에 게시되었던 글입니다.*

>출처 : yxxyun, 2014 년 6월 19일, 02:52:38 AM

>>출처 : skycoin, 2014 년 6 월 19 일, 02:31:59 AM

>>>출처 : FrictionlessCoin, 2014 년 6월 18일, 09:15:07 PM

>>>>출처 : skycoin, 2014년 6월 18일, 09:08:56 PM

>>>>개발 업데이트 :

>>>>우리는 하이브리드 증명 시스템(Proof of Stake system)을 사용하여 Sybil 공격을 
>>>>예방하는 방법을 알아냈습니다.

>>>>한 개의 노드를 만들기 위해서, 당신은 당신이 코인을 보유하고 있는지를 증명해야 합니다.
>>>>10코인이 있습니다. 당신은 10코인을 주소 A로 보냅니다.
>>>>다음 당신은 10코인을 주소 A에서 B로 보냅니다. 다음 당신은 당신의 Obelisk 블록체인 내
>>>>메시지를 등록하기 위해 주소 A의 공개키를 이용하여 서명을 추가합니다.

>>>>또는, 당신은 주소 A의 공개키를 게시한 다음 공개키를 사용하여 메시지에 서명할 수 있습니다.
>>>>노드는 다른 피어와의 유효한 신뢰 관계를 유지하기 위해 매 시간마다 
>>>>또는 예비 코인의 일부 블록 내에 서명을 발행해야합니다.

>>>>또는, 코인이 주소 A에서 개인 키가 없는 주소 B로 전송되었다는 연소 증거가 필요할 수 있습니다.
>>>>연소 증거는 그 누구도 완전한 노드를 조작하기 위해 전체 블록 체인을 처음부터 다운로드해야 
>>>>할 필요가 없다는 요구와 충돌하기 때문에 거의 불가능합니다.

>>>>이 시스템은 Obelisk 노드 수를 상한선으로 지정하고 
>>>>Obelisk 노드를 코인 홀더로 실행할 수 있는 기능을 제한합니다.
>>>>노드 수와 코인 요구 사항의 상한은 Sybil 공격 방어의 또 다른 계층을 추가합니다.

>>>이것이 어떻게 Sybil 공격을 막을지는 확신할 수 없습니다.
>>>네트워크에 노드를 추가하기 위해서는 단순히 비용을 증가시키기만 하면 되고
>>>결국 sybil공격을 하기 위해서는 재정적인 비용이 필요할까요?

>>이 단계에서 아이디어가 있습니다. 개선점을 찾았습니다. 각 Obelisk 노드는, 
>>한 개의 공개키를 가지고 있습니다. 우리는 공개키를 하나의 주소로 해시한 다음 
>>해당 주소가 가지고 있는 결과값에 10코인을 저장합니다.

>>그것은 비용을 추가하지 않습니다. 그것은 단지 당신이 10 개의 코인을 소유하고 있음을 증명합니다.
>>그것은 당신이 10코인을 보유하고 있는 주소의 공개키를 위한 그 개인키를 알고 있음을 증명합니다.
>>당신은 여전히 그 코인을 사용할 수 있습니다. 

>>아이디어는 노드의 수를 상한으로 설정한다는 것입니다. 
>>만약 10 개의 코인을 보유해야하고 1 억 개의 코인이 있는 경우
>>1,000만 개의 노드에서 네트워크의 상한선을 설정합니다.
>>상한값은 수학적으로 유용하지는 않지만 지금 염두에 두어야 할 사항입니다.

>>새로운 Obelisk 노드가 실행될 때, 임의의 피어를"신뢰"합니다. 
>>사용자는 수작업으로 노드를 신뢰 그룹에 추가할 수도 있습니다.
>>(거래소 또는 신뢰할 수 있는 커뮤니티 회원)
>>노드는 공개키 해시로 식별되고 DHT에서 찾을 수 있습니다.
>>노드가 IP: 포트 쌍인 비트코인과 다릅니다. 
>>컴퓨터를 이동할 수 있으며 노드의 ID는 IP 주소에 의존하지 않습니다.

>>우리는 임의의 노드를 선택하여 네트워크를 보호하고자 합니다. 
>>우리는 3명의 개발자 노드가 네트워크를 제어하는 리플과 같은 상황을 원하지 않습니다. 
>>그러나 우리는 누군가가 200,000 개의 노드를 실행하고 새로운 사용자로부터 신뢰 관계를
>>수집하려고 하는 상황을 방지하고자 했습니다.
>>이 Sybil 공격 노드는 여전히 51% 공격을 할 수 없지만 공격 비용을 증가시키는 것은 여전히 유용합니다.

>>아마도, 우리는 새로운 사용자가 코인 잔고가 있는 노드를 무작위로 신뢰하도록 제한할 수 있습니다. 
>>신뢰 관계는 노드가 코인 잔고가 없다면 성립되지 않을 것이지만, 
>>그들은 단지 새로운 무작위 유저들을 얻지 못할 것입니다.

>>신뢰 관계에 대한 연결 그래프는 완전히 연결된 임의의 그래프로 가정됩니다. 
>>일부 노드(신뢰할 수 있는 커뮤니티 회원, 교환소, 웹 사이트, 조직)는
>>신뢰 관계가 더 커지고 이는 합의를 위한 적용 시간을 조금 늘리는 데 도움이 됩니다. 
>>그것은 네트워크 격차를 조금 줄입니다. 
>>일부 노드는 합의를 확인하는데 사용되며 노드는 합의 결정에 
>>영향을 주지 않지만 노드가 네트워크로 수렴했는지 확인하는 "합의된 신탁"입니다.

>>만약 두 개의 거대 거래소가 특정한 블록에 대해 서로 다른 의견을 가지고 있다면 문제입니다. 
>>네트워크 분할 또는 네트워크 공격을 나타낼 수 있습니다. 
>>거래소는 문제가 해결될 때까지 거래를 중지할 수 있습니다.

>Obelisk는 스카이코인 배포 합의 노드입니까? 저는 스카이코인이 노드라고 생각했습니다...

네.

스카이코인은 블록체인을 가지고 있습니다. 블록 체인은
https://github.com/skycoin/skycoin/tree/develop/src/coin 에 있습니다. 
이것은 블록을 구문 분석하고 소비되지 않은 출력 및 트랜잭션을 처리합니다.

스카이와이어는 데몬이며 "서비스 아키텍처"를 가지고 있습니다. 
블록 체인 동기화 서비스 및 기타 서비스와 같은 서비스를 실행할 수 있습니다. 
메쉬 네트워크는 현재 스카이와이어 위에 서비스로 구현되고 있습니다.(이것은 변경이 필요할 수도 있음)

합의 메커니즘은 블록 체인 외부에 있습니다.
노드(아마도 스카이와이어 서비스로 구현될 것)는 블록 체인을 가지고 있습니다.
각 노드에는 공개키가 있습니다. 공개키는 Obelisk 노드를 식별합니다.
각 Obelisk 노드에는 자체 블록 체인이 있습니다.(이 체인은 코인이 없음)
노드는 새로운 블록을 생성하고 개인키로 서명합니다. 
Obelisk 블록 체인은 합의를 처리하는데 사용됩니다.(스카이코인 블록 체인의 헤드 블록을 결정)
Obelisk는 무작위 합의를 위해 Ben-Or's를 사용합니다. 
각 Obelisk 노드는 구독하는 다른 노드 목록이 있습니다. 
이러한 노드는 로컬 노드에 대한 합의 및 투표 결정에 영향을 줍니다. 
비-결함 네트워크 토폴로지의 경우, 지역 컨센서스는 글로벌 컨센서스로 수렴합니다.

각 노드는 체인의 다음 블록에 투표합니다. 노드는 다음 블록을 제안하고 
노드는 대체 노드에 투표합니다. 투표는 각 노드에 대한 Obelisk 블록 체인의 
블록에 게시됩니다. 당신의 노드는 후보 중에서 무작위로 투표하고 매시간 투표를 뒤집습니다. 
당신의 피어의 40%(동의한 노드)가 합의에 도달하면 해당 후보로 전환합니다. 
네트워크는 한 번에 여러 포크에 투표할 수 있습니다. 
합의를 기다리지는 않습니다. 포크는 시간이 지남에 따라 하나의 체인으로 정리됩니다. 
두 개 또는 세 블록의 분할은 정상이지만 몇 번의 확인 후에 블록이 되돌아올 
확률은 0으로 기하 급수적으로 감소합니다. 트랜잭션이 모든 후보 체인에서 실행된 경우 
특정 합의 체인이 아직 결정되지 않은 경우에도 본질적으로 실행됩니다.

그것은 Ben-Or의 바이너리이며 스카이코인은 합의 세트에서 선택할 수 있는 
후속 블록이 여러 개 있을 때 더 빠르고, 개선된 기능을 사용할 수 있습니다.
랜덤화는 네트워크의 하위 그래프가 멈추지 않도록 하기위해 중요합니다. 
투표 프로세스는 "어닐링(annealing)"의 한 형태로서 각 노드는 지역 정보만으로 
글로벌 컨센서스에 독립적으로 도달하게됩니다.

합의 과정은 공개적으로 진행됩니다. 노드는 블록을 게시하고 개인키로 서명하며 
블록은 체인 구독자간에 P2P로 복제됩니다. 그 다음 합의를 입증하는데 사용되지만 
합의에 영향을 미치지 않는 노드인 "합의 신탁"이 있습니다. 
따라서 당신은 몇 개의 거래소의 공개키와 몇 명의 신뢰할 수있는 커뮤니티 멤버를 선택할 수 있습니다.
노드는 무언가 잘못되었을 때 이를 감지하기 위해 노드를 사용합니다. 
이것은 네트워크 분리를 감지하는 데 사용됩니다. 
또한 해커가 라우터를 제어하고 당신이 연결할 수 있는 피어를 제어할 수있는 공격으로부터 보호합니다.

만약 노드가 네트워크에 표시되고 다른 체인(51 % 공격, 트랜잭션 되돌리기)을 받아들이도록 
네트워크를 시도하면 일반적으로 무시됩니다. 대부분의 51%의 공격은 악의적인 노드 동작을 
자동으로 감지하여 구독 노드가 악의적인 노드를 신뢰 목록에서 제거하도록 합니다.
가장 쉬운 51% 공격 전략은 탐지하기 쉽고 블록 컨센서스 결정을 되돌려야 하기 때문에 
거래를 되돌리려고 의도된 것으로 수학적 확실성을 입증합니다. 
동일한 시퀀스 번호를 가진 두 개의 서명된 블록을 게시해야 하므로 
노드에 대해 자동으로 차단 공격을 가합니다.

우리는 노드의 서브 네트워크가 오프라인 상태가 될 때(네트워크 분할 공격) 
마지막으로 가능한 51%의 공격을 제거하려고 시도하고 다른 블록 체인 합의를 통해 
네트워크에 다시 참여하여 네트워크에서 트랜잭션을 되돌리려고 시도합니다. 
서브넷의 영향력이 충분하지 않기 때문에 대부분의 공격은 실패합니다.

이 공격은 여전히 매우 어렵습니다. 51%의 공격이 성공한 경우, 
하나의 해결책은 네트워크를 정지시키고 각 노드/사용자가 어떤 체인이 
유효한 체인인지 개별적으로 선택하게 하고 공격 노드를 수동으로 
차단하도록 하는 것입니다. 합의 신탁은 각 노드가 높은 확률로 상태가 동기화 되었는지, 
그리고 글로벌 컨센서스에 도달했는지 또는 그것이 네트워크 분할 하위 그래프의 
일부인지 여부를 알 수 있게 합니다. 
우리는 각 노드가 지역 정보가 높은 정확성을 가지고 있는 지를 알 수 있고, 
컨센서스 결정 중에 어떤 노드가 오프라인인지 식별할 수 있으며, 
갑자기 나타나는 오프라인 상태의 노드를 무시하고 네트워크에서 
체인 포크를 강제 실행하는 것이 가능하다고 생각합니다.  

비트코인에서 해시파워가 가장 큰 경우에는 언제든지 트랜잭션을 되돌릴 수 있습니다.

스카이코인에서 트랜젝션을 되돌리려면 :

- 당신은 많은 수의 노드를 제어해야 합니다.
- 사용자가 제어하는 노드는"영향력"이 있어야 하며 네트워크 토폴로지 내에서 신뢰할 수 있어야 합니다.
- 당신의 노드는 탐지되지 않는 상태에서 매우 노골적인 공격 행위가 필요합니다.
  탐지는 당신이 네트워크를 공격하는데 필요한 신뢰 관계를 약화시키는 결과를 불러오기 때문입니다.
- 당신의 노드는 탐지되지 않는 공격 토폴로지 내에 있어야 합니다.
  (대부분의 봇 노드는 극소수의 사람에 의해 신뢰되며, 매우 분명합니다.)
- 성공적인 공격을 유도하는 방식으로 당신이 통제하는 노드를 결집시킬 수 있어야 합니다.
  (이것은 그리 간단하지 않습니다.)
- 만약 공격이 성공한다면 수동으로 공격이 되돌려지는 것에 대해 네트워크를 보호해야 합니다.
  (만약 사람들이 공격때문에 코인이나 돈을 잃어 버린다면 매우 어렵습니다.)

그것이 51% 공격 기반이라는 것을 증명하기 위해, 당신은 
당신이 만들고 있는 가정을 적어 놓은 다음 간단한 수학적 모델을 만들고
그 모델에서 일어날 수 있는 일과 할 수 없는 일을 증명해야 합니다. 
공격이 가능한 조건을 알고 나면. 당신은 그것들을 제거하는 것을 시도하고
만약 당신이 그것들을 제거할 수 없다면, 당신을 그것을 가능성이 낮은 것으로 간주합니다.
당신이 공격비용을 증가시키면 특정 공격 성공확률이 줄어듭니다. 
그 다음 당신은 공격에 대한 보상과 인센티브를 줄입니다.

합의 프로세스는 간단하고 모델링하기 쉽지만, 이를 알지 않고는 직관적일 수 없습니다.
당신이 활용할 수 있는 애니메이션 합의 프로세스 자바스크립트 사이트가 개설될 것입니다.
